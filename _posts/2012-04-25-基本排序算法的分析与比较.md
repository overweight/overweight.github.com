---
layout: post
title: "基本排序算法的分析与比较"
category: "算法设计"
---
{% include JB/setup %}

##序
####分类

在计算机科学所使用的排序算法通常被分类为： 

- **计算的复杂度**（最差、平均、和最好性能），依据列表（list）的大小（n）。一般而言，好的性能是O(n log n)，且坏的性能是O(n2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。  
- **存储器使用量（以及其他电脑资源的使用）**  
- **稳定度：**  
稳定排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。也就是一个排序算法是稳定的，就是当有两个有相等关键的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。  
一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和快速排序。选择排序包含希尔排序和堆排序。  
- **稳定度**  
当相等的元素是无法分辨的，比如像是整数，稳定度并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。 

- (4, 1)  (3, 1)  (3, 7)  (5, 6)  

在这个状况下，有可能产生两种不同的结果，一个是依照相等的键值维持相对的次序，而另外一个则没有：  

- (3, 1)  (3, 7)  (4, 1)  (5, 6)   (維持次序)  
- (3, 7)  (3, 1)  (4, 1)  (5, 6)   (次序被改變)   

不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，（比如上面的比较中加入第二个标准：第二个键值的大小）就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。    
####排列算法列表

在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。    
#####**稳定的**
- 冒泡排序（bubble sort） — O(n2)  
- 鸡尾酒排序 (Cocktail sort, 双向的冒泡排序) — O(n2)  
- 插入排序 （insertion sort）— O(n2)  
- 桶排序 （bucket sort）— O(n); 需要 O(k) 额外空间  
- 计数排序 (counting sort) — O(n+k); 需要 O(n+k) 额外空间  
- 合并排序 （merge sort）— O(n log n); 需要 O(n) 额外空间  
- 原地合并排序 — O(n2)  
- 二叉排序树排序 （Binary tree sort） — O(n log n)期望时间; O(n2)最坏时间; 需要 O(n) 额外空间  
- 鸽巢排序 (Pigeonhole sort) — O(n+k); 需要 O(k) 额外空间  
- 基数排序 （radix sort）— O(n·k); 需要 O(n) 额外空间  
- Gnome 排序 — O(n2)
- 图书馆排序 — O(n log n) with high probability, 需要 (1+ε)n 额外空间  
#####**不稳定**
- 选择排序 （selection sort）— O(n2)  
- 希尔排序 （shell sort）— O(n log n) 如果使用最佳的现在版本  
- 组合排序 — O(n log n)  
- 堆排序 （heapsort）— O(n log n)  
- 平滑排序 — O(n log n)  
- 快速排序 （quicksort）— O(n log n) 期望时间, O(n2) 最坏情况;   
 对于大的、乱数列表一般相信是最快的已知排序  
- Introsort — O(n log n)  
- Patience sorting — O(n log n + k) 最坏情况时间，需要 额外的 O(n + k)   空间，也需要找到最长的递增子串行（longest increasing subsequence）  
#####**不实用的排序算法**
- Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷。  
- Stupid sort — O(n3); 递归版本需要 O(n2) 额外存储器  
- 珠排序（Bead sort） — O(n) or O(√n), 但需要特别的硬件  
- Pancake sorting — O(n), 但需要特别的硬件  
- Stooge排序 算法简单，但需要约n^2.7的时间  
####平均时间复杂度

平均时间复杂度由高到低为：  

- 冒泡排序 O(n2)  
- 插入排序 O(n2)  
- 选择排序 O(n2)  
- 归并排序 O(n log n)  
- 堆排序 O(n log n)  
- 快速排序 O(n log n)  
- 希尔排序 O(n1.25)  
- 基数排序 O(n)  
说明：虽然完全逆序的情况下，快速排序会降到选择排序的速度，不过从概率角度来说(参考信息学理论，和概率学)，不对算法做编程上优化时，快速排序的平均速度比堆排序要快一些。  

##设计思想
　　排序是数据处理中使用频率很高的一种操作，是数据查询之前需要进行的一项基础操作。它是将任意序列的数据元素（或记录）按关键字有序（升序或降序）重新排列的过程。排序的过程中有两种基本操作：一是比较两个关键字的值；二是根据比较结果移动记录位置。  
　　排序的算法有很多种，这里仅对插入排序、选择排序、希尔排序、归并排序和快速排序作了比较。    
###直接插入排序算法基本思路：   
　　直接插入排序时将一个元素插入已排好的有序数组中，从而得到一个元素个数增加1的新的有序数组。其具体实现过程是，将第i个元素与已经排好序的i-1个元素依次进行比较，再将所有大于第i个元素的元素后移一个位置，直到遇到小于或等于第i个元素，此时该元素的后面一个位置为空，将i元素插入此空位即可。  
　　
###选择排序算法基本思路：
　　定义两个数组sela[]和temp[]，sela[]用来存放待排序数组，temp[]用来存放排好序的数组。第一趟，将sela[]数组中n个元素进行比较，找出其中最小的元素放入temp[]的第一个位置，同时将sela[]中将该元素位置设置为无穷大。第二趟，将sela[]数组中n个元素进行比较，找出其中最小的元素放入temp[]的第二个位置，同时将sela[]中将该元素位置设置为无穷大。以此类推，n趟后将sela[]中所有元素都已排好序放入temp[]数组中。  
###希尔排序算法基本思路： 
　　希尔排序又称为变长步径排序，它也是一种基于插入排序的思想。其基本思路是，定义一个步长数组gaps[1,5,13,43……]，先选取合适的大步长gap将整个待排序的元素按步长gap分成若干子序列，第一个子序列的元素为a[0]、a[0+gap]、a[0+2gap]……a[0+k*gap];第二列为a[1]、a[1+gap]、a[1+2gap]……a[1+k*gap]；……。
　　然后，对这些子序列分别进行插入排序，然后将gap按gaps[]数组中的步长缩小，按缩小后的步长再进行子序列划分排序，再减小步长直到步长为1为止。
###归并排序算法基本思路：  
　　归并排序是将两个或两个以上的有序表合并成为一个新的有序表。其基本思路是，将n个待排元素从top到bottom中间分成两部分left[top]~left[mid]和right[mid+1]~ right[bottom]。再将left和right每部分分别从中间分成两部分，这样一直分下去，直到分成的两部分数组长度为1。  
　　然后，将相邻的两个子数组比较大小后两两依次合并，直到最后变成一个长度为n的有序数组，这就是所需数组。  
###快速排序算法基本思路：  
　　快速排序算法是一种特殊是归并排序，它是在切分的时候按大小分开，最后再合并。其基本思路是，将n个待排数的第一个数作为支点pivot，将比pivot小的数存入small[]数组中，比pivot大的数存入big[]数组中。再分别以small[]数组和big[]数组中的第一个数作为pivot对small[]数组和big[]数组进行切分。最后直到按支点pivot划分后small[]和big[]中为空或只有一个元素时停止切分。  
　　按照small[]、pivot、big[]的顺序将切分后的元素进行合并就得到长度为n的有序数组，即为所需。  

##性能分析
![各排序算法的性能分析][1]
  [1]:http://img.ph.126.net/CLg8EDyXENYFR43ETr5wVw==/3355463197369015257.jpg
  
