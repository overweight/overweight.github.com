---
layout: post
title: "用ptrace设置断点进行调试"
category: "linux"
---
**更正：本文中的®s、应更改为&regs；#include<linux/user.h>更改为#include<sys/user.h>,否则程序编译不通过**


###1.linux系统结构 
在 Linux 系统结构中,最核心的是计算机硬件,它提供对 Linux 软件的支持,靠近硬件的内层是 Linux 内核程序(即操作系统)。内核直接和硬件打交道是程序和硬件之间的接口或界面。
它对一切外层程序提供公共服务,把外部程序同硬件隔离开。内核程序大致可分为文件系统管
理,进程管理,内存管理等几部分。进程管理又分为低级进程管理和高级进程管理。低级进程
管理主要包括:进程调度分配,控制占用处理器的程序和基本的进程通信。高级进程管理主要
包括:进程的创建,终止,进程间通信,进程在内存和外存之间的转储,信号机构和进程间跟
踪控制等。内核程序的外层是实用程序,内核提供对实用程序的支持,两层之间的界面是系统
调用。内核外的实用程序通过系统调用来和内核打交道。实现的过程是通过一种特殊的指令(陷
入指令)进入内核,然后转入相应的系统调用处理程序。这也是本文将主要讨论的问题。

###2.80386体系结构
80386 的体系结构承认两类事件。

1. 异常(exceptions)
2. 中断(interrupts)

他们两都会引起“上下文转换”同时建立一个过程或任务,中断可以随时随地发生(包括
在执行程序时)所以用来响应硬件信号。而异常则由指令内部错误引起。

每一个异常或中断都有一个唯一的标识符,在 linux 中被称为向量。

指令内部异常和 NMI(不可屏蔽中断)的中断向量的范围从 0—31。32-255 的任何向量都可以
用做

1. 可屏蔽中断
2. 编程(调试)异常

至于可屏蔽中断则取决于该系统的硬件配置。外部中断控制器在中断响应周期把中断向量
放到总线上。
###3.linux系统调用流程概述
Linux 系统调用的流程非常简单,它由 0x80 号中断进入系统调用入口,通过使用系统
调用表保存系统调用服务函数的入口地址来实现,本文首先分析一般 Linux 系统调用的流
程,然后再分析 Linux 系统调用 sys_ptrace().
###4.ptrace函数介绍
名字

    ptrace – 进程跟踪

形式

    #include <sys/ptrace.h>   
    int ptrace(int request, int pid, int addr, int data); 

描述

    Ptrace 提供了一种父进程可以控制子进程运行，并可以检查和改变它的核心image。它主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。  

Request参数决定了系统调用的功能：

    PTRACE_TRACEME 
    　　　本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。 
    PTRACE_PEEKTEXT, PTRACE_PEEKDATA 
    　　　从内存地址中读取一个字节，内存地址由addr给出。
    PTRACE_PEEKUSR 
    　　　从USER区域中读取一个字节，偏移量为addr。 
    PTRACE_POKETEXT, PTRACE_POKEDATA 
    　　　往内存地址中写入一个字节。内存地址由addr给出。
    PTRACE_POKEUSR 
    　　　往USER区域中写入一个字节。偏移量为addr。
    PTRACE_SYSCALL, PTRACE_CONT 
    　　　重新运行。 
    PTRACE_KILL 
    　　　杀掉子进程，使它退出。 
    PTRACE_SINGLESTEP 
    　　　设置单步执行标志 
    PTRACE_ATTACH 
    　　　跟踪指定pid 进程。 
    PTRACE_DETACH 
    　　　结束跟踪
    Intel386特有：
    PTRACE_GETREGS
    　　　读取寄存器
    PTRACE_SETREGS
    　　　设置寄存器
    PTRACE_GETFPREGS
    　　　读取浮点寄存器
    PTRACE_SETFPREGS
    　　　设置浮点寄存器
    init进程不可以使用此函数

返回值

    成功返回0。错误返回-1。errno被设置。

错误

    EPERM 
    　　　特殊进程不可以被跟踪或进程已经被跟踪。
    ESRCH 
    　　　指定的进程不存在
    EIO 
    　　　请求非法
###5.函数详细描述
- PTRACE_TRACEME   
形式：ptrace(PTRACE_TRACEME,0 ,0 ,0)  
描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。 

- PTRACE_PEEKTEXT, PTRACE_PEEKDATA     
形式：ptrace(PTRACE_PEEKTEXT, pid, addr, data)  
ptrace(PTRACE_PEEKDATA, pid, addr, data)  
描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。在Linux（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。

- PTRACE_POKETEXT, PTRACE_POKEDATA   
形式：ptrace(PTRACE_POKETEXT, pid, addr, data)    
ptrace(PTRACE_POKEDATA, pid, addr, data)  
描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。

- PTRACE_PEEKUSR   
形式：ptrace(PTRACE_PEEKUSR, pid, addr, data)  
描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。
 
- PTRACE_POKEUSR   
形式：ptrace(PTRACE_POKEUSR, pid, addr, data)  
描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。
 
- PTRACE_CONT   
形式：ptrace(PTRACE_CONT, pid, 0, signal)  
描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。

- PTRACE_SYSCALL    
形式：ptrace(PTRACE_SYS, pid, 0, signal)    
描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。与PTRACE_CONT不同的是进行系统调用跟踪。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。

- PTRACE_KILL   
形式：ptrace(PTRACE_KILL,pid)  
描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。 

- PTRACE_SINGLESTEP   
形式：ptrace(PTRACE_KILL, pid, 0, signle)  
描述：设置单步执行标志，单步执行一条指令。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。

- PTRACE_ATTACH   
形式：ptrace(PTRACE_ATTACH,pid)  
描述：跟踪指定pid 进程。pid表示被跟踪进程。被跟踪进程将成为当前进程的子进程，并进入中止状态。

- PTRACE_DETACH   
形式：ptrace(PTRACE_DETACH,pid)  
描述：结束跟踪。 pid表示被跟踪的子进程。结束跟踪后被跟踪进程将继续执行。

- PTRACE_GETREGS  
形式：ptrace(PTRACE_GETREGS, pid, 0, data)  
描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。

- PTRACE_SETREGS  
形式：ptrace(PTRACE_SETREGS, pid, 0, data)  
描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。

- PTRACE_GETFPREGS  
形式：ptrace(PTRACE_GETFPREGS, pid, 0, data)  
描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。

- PTRACE_SETFPREGS  
形式：ptrace(PTRACE_SETREGS, pid, 0, data)  
描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值。

###6.ptrace 的使用
ptrace 提供了一种父进程可以控制子进程运行,并可以检查和改变它的核心的功能,ptrace 大多被调试器所使用。  

####6.1 启动、中止调试程序  

   **启动调试程序**  
   
调试器对一个程序进行调试,如果此程序没有在运行,则调试器需要装入其代码,并创
建相应的进程,并使其进入调试状态。其使用 ptrace 实现的方法如下:    

    int pid;
    pid = fork ();
    if (pid < 0)
    perror_with_name ("fork");
    if (pid == 0)
    {
        ptrace (PTRACE_TRACEME, 0, 0, 0);
        execv (program, allargs);
        /* char *program;
        char **allargs; 指向程序名和参数
        fprintf (stderr, "Cannot exec %s: %s.\n", program,
        errno < sys_nerr ? sys_errlist[errno] : "unknown error");
        fflush (stderr);
        _exit (0177);
    }
    wait(pid);
    ptrace (PTRACE_CONT, pid, 0, 0);
    wait(pid);
    
首先调试器需创建进程、装入代码。调用 fork(),创建子进程。对于子进程首先调用
ptrace (PTRACE_TRACEME, 0, 0, 0),进程标志 PF_PTRACED 置位,子进程进入调试状态。
再执行 execv 系统调用,系统装入可执行文件代码,装入完毕后,则会向自身发送 SIGTRAP
信号(参见 execve 分析)。这时,子进程已经进入调试状态(PF_PTRACED 置位),则在处
理 SIGTRAP 信号的时候, 中止进程执行,并通知调试器(其父进程)让其运行,父进程则
从 wait 调用中返回(参见 do_signal 分析)。至此,要调试的程序已经调入、并作为调试器
的一个子进程运行,并中止在程序的第一条指令上。  

接着为了让子进程运行,父进程调用 ptrace (PTRACE_CONT, pid, 0, 0),从而使子进程
继续执行。再调用 wait 等待子进程中断或退出。  在 GDB 调试器中命令 run 则是通过上述方法完成运行调试运行程序的。  

**对现有进程进行调试**  

调试器还能对已经运行的进程进行调试。通过调用 ptrace 的 PTRACE_ATTACH 功能可
以实现。具体做法如下:

    ptrace(PTRACE_ATTACH,pid, 0,0)
    wait(pid);
    
首先调用 ptrace(PTRACE_ATTACH,pid, 0,0)。ptrace 为完成对这个进程的调试设置,
首先设置进程标志置 PF_PTRACED。再将它设置为调试器的子进程,最后向它发信号
SIGSTOP 中止它的运行,使它进入调试状态。(具体分析见 ptrace 函数分析)
调试器在调用 ptrace 后需调用 wait,等待要调试的进程进入 STOP 状态。
在 GDB 调试器中命令 attach 则是通过上述方法调试现有的进程的。

**退出对进程调试**

对于使用 ptrace 的 PTRACE_ATTACH 功能调试的程序,希望放弃调试,使其继续执行
时可以使用 ptrace 的 PTRACE_DETACH 功能。

调用了ptrace(PTRACE_DETACH,pid,0,0),终止调试一个子进程。此处理与PTRACE_ATTACH处理相反。在此做一些清理操作:清除PF_TRACESYS和PF_PTRACED 进程标志,清除TF标志,父进程指针还原。最后唤醒此进程,让其继续执行(具体分析见 ptrace 函数分析)。

在 GDB 调试器中命令 detach 则是通过上述方法调试现有的进程的。

**终止调试进程运行**

对被调试的进程,不想再调试时,可以调用 ptrace 的 PTRACE_KILL 功能杀死被调试
的进程。

调用了 ptrace(PTRACE_KILL,pid, 0,0),把子进程继续的信号设置为 SIGKILL,然后
唤醒子进程,由于子进程是在 do_signal 处理中进入 stop 的,所以它将继续处理 SIGKILL 部分的代码,从而使子进程终止。(具体分析见 ptrace 函数分析)
在 GDB 调试器中命令 kill 则是通过上述方法调试现有的进程的。

####6.2. 调试进程的控制
**中止进程运行**  

在使用调试器调试程序时,被调试程序被中断的条件有::

1. 调试器设置的断点(指令断点和数据断点)满足条件。
2. 进程收到一个信号(SIGKILL 除外)
。
3. 单步调用完成。
4. 系统调用调试下,进入或离开系统调用。

A. 断点  
设置断点是调试器中的一个重要功能。80386 提供了两种方式,INT3 和利用调试寄存
器(详见前面 80386 的调试设施)。

如果使用 INT3 方式设置断点,则调试器通过 ptrace 的 PTRACE_POKETEXT 功能在断
点处插入 INT3 单字节指令。当进程运行到断点时(INT3 处),则系统进入异常 3 的处理。

若使用调试寄存器,则调试器通过调用 ptrace(PTRACE_POKEUSR,pid,0,data)在DR0-DR3 寄存器设置与四个断点条件的每一个相联系的线性地址在 DR7 中设置断点条件。

被跟踪进程运行到断点处时,CPU 产生异常 1,从而转至函数 do_debug 处理。由于子进程
在调试状态下属于正常调试异常,所以 do_debug 函数处理中产生 SIGTRAP 信号,为处理
这个信号,进入 do_signal,使被调试进程停止,并通知调试器(父进程),此时得到子进程
终止原因为 SIGTRAP。

B. 信号  

在有些情况之下,要求调试器调试某进程时,当进程收到某一信号的时候中断进程运行。
如:被调试进程在某处运算错误,进程会接收到 SIGFPE 信号,在正常运行状况下,会
Coredump,而调试的情况下则希望在产生错误代码处停止运行,可以让用户调试错误原因。
对于已经被调试的进程(PF_PTRACED 标志置位),当受到任何信号(SIGKILL 除外)
会中止其运行,并通知调试器(父进程)。(详见 do_signal 分析)

C.单步执行

单步执行也是一种使进程中止的情况。当用户调用 ptrace 的 PTRACE_SINGLESTEP 功
能时,ptrace 处理中,将用户态标志寄存器 EFLAG 中 TF 标志为置位,并让进程继续运行
(具体分析见 ptrace 函数分析)。当进程回到用户态运行了一条指令后,CPU 产生异常 1,
从而转至函数 do_debug 处理。由于子进程在调试状态下属于正常调试异常,所以 do_debug
函数处理中产生 SIGTRAP 信号,为处理这个信号,进入 do_signal,使被调试进程停止,并
通知调试器(父进程),此时得到子进程终止原因为 SIGTRAP。

D. 系统调用调试

对程序的调试,有时希望对系统调用进程跟踪。当程序进行系统调用时中断其运行。
ptrace 提 供 PTRACE_SYSCALL 功 能 完 成 此 功 能 。 在 ptrace 调 用 中 设 置 了 进 程 标 志
PF_TRACESYS,表示进程对系统调用进行跟踪,并继续执行进程(具体分析见 ptrace 函数
分析)。直到进程调用系统调用时,则中止其运行,并通知调试器(父进程)。(详见
syscall_trace 分析)

**继续进程执行**

让中断的进程继续执行,ptrace 提供三种功能

1. 继续执行(PTRACE_CONT)
2. 系统调用调试(PTRACE_SYSCALL)
3. 单步执行(PTRACE_SINGLESTEP)

三种功能的区别在于 PTRACE_CONT 功能让进程继续执行直到下一个断点或收到一个
信号会中止进程运行。PTRACE_SYSCALL 功能让进程继续执行增加了一个中止条件,进程
调用系统调用。PTRACE_SINGLESTEP 功能让进程继续执行,只执行一个机器指令,则就
中止其运行。

当被调试进程因为受到一个信号而中止时,这个信号并没有被处理。如果希望继续运行
进程时继续处理这个信号,则在上述三个 ptrace 功能调用时,最后一个参数 data 设置要继
续处理的信号。这种情况出现在,如:中止进程运行的信号为用户自定义信号,用户想继续
运行进程,而不要忽略用户信号处理。有时,用户希望忽略其信号处理,这时则参数 data
设置为 0,这种情况出现在,如:由于算术错误接收到 SIGFPE 信号使进程中止,而用户发
现了错误,重新设置了正确的值,然后希望其继续执行,这时 SIGFPE 信号则需要忽略。

####6.3 进程数据存取

当被调试进程中止的状态下,调试器一般提供给用户观察、修改程序变量的功能,以及
反汇编代码,以及观察、修改内存地址和寄存器的功能。读写代码段数据使用 ptrace 的
PTRACE_PEEKTEXT 和 PTRACE_POKETEXT 功 能 。 读 写 数 据 段 数 据 使 用 ptrace 的
PTRACE_PEEKDATA 和 PTRACE_POKEDATA 功 能 。 读 写 寄 存 器 数 据 使 用 ptrace 的
PTRACE_PEEKUSR 和 PTRACE_POKEUSR 功能。对于 Linux(i386)下可以使用 ptrace 的
PTRACE_GETREGS 和 PTRACE_PUTREGS 读 写 所 有 i386 用 户 寄 存 器 , 使 用 ptrace 的
PTRACE_GETFPREGS 和 PTRACE_PUTFPREGS 读写所有 i387 浮点寄存器。
###7.一个小例子
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <syscall.h>
    #include <sys/ptrace.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <unistd.h>
    #include <errno.h>
    
    int main(void)
    {
            long long counter = 0;  /*  machine instruction counter */
            int wait_val;           /*  child's return value        */
            int pid;                /*  child's process id          */
    
            puts("Please wait");
    
            switch (pid = fork()) {
            case -1:
                    perror("fork");
                    break;
            case 0: /*  child process starts        */
                    ptrace(PTRACE_TRACEME, 0, 0, 0);
                    /* 
                     *  must be called in order to allow the
                     *  control over the child process
                     */ 
                    execl("/bin/ls", "ls", NULL);
                    /*
                     *  executes the program and causes
                     *  the child to stop and send a signal 
                     *  to the parent, the parent can now
                     *  switch to PTRACE_SINGLESTEP   
                     */ 
                    break;
                    /*  child process ends  */
            default:/*  parent process starts       */
                    wait(&wait_val); 
                    /*   
                     *   parent waits for child to stop at next 
                     *   instruction (execl()) 
                     */
                    while (wait_val == 1407 ) {
                            counter++;
                            if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0) != 0)
                                    perror("ptrace");
                            /* 
                             *   switch to singlestep tracing and 
                             *   release child
                             *   if unable call error.
                             */
                            wait(&wait_val);
                            /*   wait for next instruction to complete  */
                    }
                    /*
                     * continue to stop, wait and release until
                     * the child is finished; wait_val != 1407
                     * Low=0177L and High=05 (SIGTRAP)
                     */
            }
            printf("Number of machine instructions : %lld\n", counter);
            return 0;
    }
> Written with [StackEdit](http://benweet.github.io/stackedit/).
